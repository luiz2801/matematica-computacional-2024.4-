'''considerando a funcao de runge abaixo, fa√ßa 3 amostras igualmente espa√ßadas de
 6, 10 e 14 pontos(X e Y).com essas amostras, plote 3 interpola√ß√µes com essas amostras. 
Plote no mesemo grafico e spline de grau 3 usando a amostra de 10 pontos.
use o intervalo [-2,2] para o eixo x. explique o que o grafico mostra. f(x)= (1)/(1+25x^2)
'''


import numpy as np
import matplotlib as plt
import scipy


def quadratic_spline_interpolation(valores_x, valores_y, x_interp):
    """
    Fun√ß√£o para calcular a interpola√ß√£o spline quadr√°tica.
    
    :param valores_x: Lista com os valores de x conhecidos
    :param valores_y: Lista com os valores de y correspondentes
    :param x_interp: Valor de x a ser interpolado
    :return: Valor interpolado
    """
    n = len(valores_x) - 1  # N√∫mero de intervalos
    a = valores_y
    b = np.zeros(n)
    c = np.zeros(n + 1)
    h = [valores_x[i + 1] - valores_x[i] for i in range(n)]
    
    # Montando o sistema de equa√ß√µes para encontrar os coeficientes c
    A = np.zeros((n + 1, n + 1))
    B = np.zeros(n + 1)
    
    A[0][0] = 1  # Condi√ß√£o de contorno natural
    A[n][n] = 1  # Condi√ß√£o de contorno natural
    
    for i in range(1, n):
        A[i][i - 1] = h[i - 1]
        A[i][i] = 2 * (h[i - 1] + h[i])
        A[i][i + 1] = h[i]
        B[i] = (3 / h[i]) * (a[i + 1] - a[i]) - (3 / h[i - 1]) * (a[i] - a[i - 1])
    
    # Resolvendo o sistema linear
    c = np.linalg.solve(A, B)
    
    # Calculando b e d
    d = np.zeros(n)
    for i in range(n):
        b[i] = (a[i + 1] - a[i]) / h[i] - h[i] * (c[i + 1] + 2 * c[i]) / 3
        d[i] = (c[i + 1] - c[i]) / (3 * h[i])
    
    # Encontrar o intervalo correto para x_interp
    for i in range(n):
        if valores_x[i] <= x_interp <= valores_x[i + 1]:
            dx = x_interp - valores_x[i]
            return a[i] + b[i] * dx + c[i] * dx**2 + d[i] * dx**3
    
    raise ValueError("x_interp est√° fora do intervalo fornecido.")

# Exemplo de uso:
valores_x = [1.0, 2.0, 3.0, 4.0]  # Valores conhecidos de x
valores_y = [2.0, 3.0, 5.0, 7.0]  # Correspondentes valores de y
x_interp = 2.5  # Valor de x a ser interpolado

resultado_spline_quadratica = quadratic_spline_interpolation(valores_x, valores_y, x_interp)
print(f"Spline Quadr√°tica: p({x_interp}) = {resultado_spline_quadratica}")






#me de o resultado disso, o codigo modificado e comentado explicando como tudo foi feito. 
# nao use bibliotecas prontas, use o codigo acima








'''

Passo a Passo do C√≥digo
Importa√ß√£o das Bibliotecas

numpy: Para manipula√ß√£o de arrays e gera√ß√£o de valores num√©ricos.
matplotlib.pyplot: Para visualiza√ß√£o gr√°fica dos resultados.
scipy.interpolate: Para realizar a interpola√ß√£o usando BarycentricInterpolator (Lagrange) e CubicSpline.
Defini√ß√£o da Fun√ß√£o de Runge'''

def runge_function(x):
    return 1 / (1 + 25 * x**2)
"""Essa √© a fun√ß√£o que ser√° interpolada.
Gera√ß√£o dos Pontos de Amostragem"""

num_points = [6, 10, 14]
x_vals_fine = np.linspace(-2, 2, 500)
y_true = runge_function(x_vals_fine)

"""Tr√™s conjuntos de pontos igualmente espa√ßados s√£o definidos com 6, 10 e 14 pontos.
x_vals_fine cria 500 pontos no intervalo [-2,2] para um gr√°fico suave.
y_true cont√©m os valores reais da fun√ß√£o.
Plotagem da Fun√ß√£o de Runge"""

plt.figure(figsize=(10, 6))
plt.plot(x_vals_fine, y_true, 'k-', label='Fun√ß√£o de Runge (Real)')
"""A fun√ß√£o de Runge √© plotada como refer√™ncia no gr√°fico.
Interpola√ß√£o Polinomial de Lagrange"""

for n in num_points:
    x_sample = np.linspace(-2, 2, n)
    y_sample = runge_function(x_sample)
    
    poly_interp = BarycentricInterpolator(x_sample, y_sample)
    y_poly = poly_interp(x_vals_fine)

    plt.plot(x_vals_fine, y_poly, '--', label=f'Interpola√ß√£o Polinomial ({n} pontos)')
    plt.scatter(x_sample, y_sample, marker='o', label=f'Amostras ({n} pontos)')

"""Para cada conjunto de amostras (6, 10 e 14 pontos), √© criada uma interpola√ß√£o polinomial usando BarycentricInterpolator.
A interpola√ß√£o √© plotada como linha pontilhada --.
Os pontos amostrados s√£o marcados no gr√°fico.
Interpola√ß√£o Spline C√∫bica (apenas para 10 pontos)"""


x_spline = np.linspace(-2, 2, 10)
y_spline = runge_function(x_spline)
cs = CubicSpline(x_spline, y_spline, bc_type='natural')

y_spline_vals = cs(x_vals_fine)
plt.plot(x_vals_fine, y_spline_vals, '-.', label='Spline C√∫bica (10 pontos)')
"""Apenas a amostra de 10 pontos √© usada para criar um spline c√∫bico natural (bc_type='natural' garante derivadas segundas nulas nas bordas).
O spline √© avaliado nos pontos x_vals_fine e plotado com a linha tra√ßo-ponto"""


"""me explique o resultado do grafico gerado"""





"""An√°lise do Gr√°fico Gerado
O gr√°fico compara diferentes m√©todos de interpola√ß√£o aplicados √† fun√ß√£o de Runge 

f(x)=11+25x2
f(x)=1+25x21

 , destacando as limita√ß√µes da interpola√ß√£o polinomial e a estabilidade da spline c√∫bica.

Observa√ß√µes Importantes
Curva Preta (Fun√ß√£o de Runge - Real)

Representa a fun√ß√£o original, suave e sim√©trica em rela√ß√£o ao eixo y
Possui um pico central e valores que rapidamente diminuem nas extremidades.
Interpola√ß√£o Polinomial (Linhas Pontilhadas - 6, 10 e 14 pontos)

Para 6 pontos (linha azul pontilhada), a interpola√ß√£o aproxima bem a fun√ß√£o, mas j√° apresenta alguma distor√ß√£o nas bordas.
Para 10 pontos (linha laranja pontilhada), a oscila√ß√£o nas extremidades come√ßa a aumentar.
Para 14 pontos (linha verde pontilhada), h√° oscila√ß√µes intensas perto das bordas do intervalo, um fen√¥meno conhecido como efeito de Runge.
Spline C√∫bica (Linha Vermelha Tra√ßo-Ponto - 10 pontos)

Suaviza a interpola√ß√£o, evitando oscila√ß√µes excessivas nas extremidades.
Aproxima melhor a fun√ß√£o real sem gerar grandes distor√ß√µes.
Pontos Amostrados (Marcadores Coloridos)

Os pontos usados na interpola√ß√£o s√£o bem vis√≠veis.
A interpola√ß√£o polinomial passa exatamente por esses pontos, mas apresenta oscila√ß√µes n√£o desejadas nas regi√µes intermedi√°rias.
Conclus√£o
Interpola√ß√£o polinomial com muitos pontos piora a aproxima√ß√£o devido ao efeito de Runge, que faz a fun√ß√£o interpolada oscilar intensamente nas extremidades.
Splines c√∫bicas s√£o mais est√°veis, pois interpolam os dados suavemente sem gerar oscila√ß√µes descontroladas.
Se precisar de uma interpola√ß√£o confi√°vel, usar spline c√∫bica √© geralmente a melhor escolha.
Se quiser ajustes no c√≥digo ou outra explica√ß√£o, s√≥ avisar! üöÄ"""